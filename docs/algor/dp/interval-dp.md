## 区间作为阶段

典型的题目就是合并石子，能量项链这种。

题面一般会说 “**合并**” 之类的词，状态一般会是 $f_{l,r}$ 表示将区间 $l,r$ 全部合并的最优价值。

当然也有可能是 “处理完这个区间的最优”，那么做法相应的会有一点变化（比如 CQOI的涂色，和老王去关路灯那个题）

做法是以区间作为阶段，然后枚举区间左端点。

再在每一个区间里找到一个“分割点”，把前后两个部分合并起来并加上操作的权值即可。

代码一般长这样：

```cpp
init(); //预处理长度为 1,...,a 的区间

for(int len = a + 1; len <= n; ++len) {
    for(int i = 1; i + len - 1 <= n; ++i) {
        int j = i + len - 1;
        for(int k = i; k < j; ++k) {
            f[i][j] = min/max(f[i][j], f[i][k] + f[k + 1][j] + calc(k)); 
            //calc(k) 是从 k, k+ 1 这里断开的操作价值。
        }   // k 表示 从 k, k + 1 这两个点中间断开，所以 k < j。
    }
}
```

## 断环成链

当区间DP问题被放到环上的时候可以采取。

只需要把原序列复制一边扔到后面即可。

```cpp
a1, a2, a3, a4, a5,...an, a1, a2, a3,......an
```

相应的，初始化和读入操作需要的数的时候也需要复制并扩展一倍。

假设问题要求的是整个环合并起来的最优解，那么循环求最优解需要这么写：

```cpp
int res = 0;
for(int i = 1; i <= n; ++i) {
	int j = i + n - 1; // [i,j] 是断环成链之后所有长度为 n 的区间
    res = max(res, f[i][j]);
}
```

## 分割型

问题一般是给你一个序列，要求你把他分成 $m$ 个部分，使得权值和最大。

这里的**权值和会随着分割部分的不同而变化**。

那么设 $f_{i,j}$ 从 $1\to i$ 构成的序列，分割成 $j$ 部分的所有方案，属性为权值和的最值。

考虑从 “最后一个” 下手，也就是 “最后一个部分”。

那么我们可以在 $1 \to i$ 这一段上枚举一个分割点 $k$。

使得 $[k+1,i]$ 构成第 $j$ 部分。

因为前面必须要分割成 $j-1$ 个部分，所以 $1 \to k$ 起码要有 $j - 1$ 个元素，那么实际枚举的时候 $k \in [j-1,i)$ 才行。 

所以可以得到状态转移方程：$f_{i,j}=\max\limits_{j - 1\le k < i}\{f_{k,j-1}+w_{k+1,i}\}$

$\max()$ 是直接在函数里的所有变量当中取 $\max$ ，而 $\max\{\}$ 表示在所有的可能里取最大值。

此处的决策变量是 $k$ ，所以是在所有的 $k$ 代表的 $f_{k,j-1}+w_{k+1,i}$ 当中取最大值（在决策集合中取最大值）。

$w$ 一般可以通过预处理得到。

方程直接根据题魔改即可。

```cpp
memset(f, 0, sizeof f);

for(int i = 1; i <= n; ++i) {
	for(int j = 1; j <= m; ++j) {
        for(int k = j - 1; k < i; ++k) {
            f[i][j] = max(f[i][j], f[k][j - 1] + w(k + 1,i));
        }
    }
} 
ans = f[n][m];
```

 典型题有 IOI2000 的邮局和 IOI1999 的花店橱窗布置。

!!! note "一些想法"

     最近（`May/05/2022`）发现这个方程挺常见的（

     而且还有很多变式，比如这东西实际上可以滚动数组，

     $i, j$ 分别作为阶段都是可以保证后效性的。 

     如果题目没有要求你具体要分多少段，可以省去第二维和 $j$ 的枚举，并且 $k$ 的取值范围将会变成 $0 \le k < i$。

     很多数据结构优化 DP 题都会遇到这个方程(的变式)。

     比如 The battle of chibi，The Bakery，Optimal Partition 都是。

     任务安排1 也用了同样的思想。

     第一题和第三、四题是没有要求分多少段，然后可以利用维护值域的树状数组代替平衡树插入决策，并以动态插入的方式保证方程的一个条件 $j < i$ 成立。

     第二题是要求了分多少段，我思考时为了统一优化方式，把 $i,j$ 交换了，但事后发现其实两个都一样（

     对这个方程的优化都是一个套路：固定外层循环，然后看内层循环决策集合的变化，根据不同情况选择数据结构进行维护。

     而且数据结构起的作用都是快速地直接得到决策集合的转移信息（最值（线段树/树状数组），总和（树状数组））。