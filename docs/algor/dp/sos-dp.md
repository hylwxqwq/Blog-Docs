
这个东西也叫 高维前缀和 或者 子集求和。

到省选以上常常会结合 FWT （快速沃尔什变换）算法。

全称 Sum Over Subset Dynamic Programming.

## 泛化

SOSDP 主要用于解决这样的一类问题：

> 给你一个序列 $a_0,a_1,a_2,\dots,a_{2^n - 1}$。
> 
> 要你求 $b_i = \sum\limits_{j \ \texttt{and}\  i = j} a_j$。
> 
> （此处的 $\sum$ 也可以换成 $\min,\max,\bigoplus$，因为它们都满足结合律和交换律？）

可能有点看不懂，稍微解释一下，此处把 $a$ 和 $b$ 的下标都看作了一个个二进制数（下标从 0 开始），

也就是说，$a$ 和 $b$ 的下标表示的是一个大小为 $n$ 的集合。

那么上面的式子也可以写成 $\sum\limits_{j \subset i} a_j$。

这个式子在干啥呢？

我们设 $a_i$ 为二进制下表示为 $i$ 的集合 （本文中记作 $S(i)$） 的权值。

$b_i$ 就表示的是 $S(i)$ 的所有子集的权值和，所以这个问题也叫 **子集求和**。

而换一个角度，我们可以把下标看成 $n$ 维空间里的一个坐标 $(x_0, x_1, x_2, \dots, x_{n - 1}), x_i \in \{0, 1\}$。 

那么这个 $b_i$ 其实就是一个 **高维前缀和**。

## 做法

首先考虑一个暴力，我们直接枚举所有子集然后计算权值和。

然后这玩意儿是 $\text{O}(3^{n})$ 的。

我们把这个式子再拿出来看看：

$$b_i = \sum\limits_{j \ \texttt{and}\ i = j} a_j$$

既然刚才都说了二进制下考虑，那我们就直接二进制拆开：

$b_i$ 可以写作 $b_{(x_0, x_1, \dots x_{n - 1})}$，然后有：

$$b_{(x_0, x_1, \dots x_{n - 1})} = \sum\limits_{y_0 \le x_0}\sum\limits_{y_1 \le x_1}\dots \sum\limits_{y_{n - 1} \le x_{n - 1}} a_{(y_0, y_1, \dots y_{n - 1})}$$

这是高维前缀和的直接表示法。

考虑一个 DP，设 $dp(msk, i)$ 表示考虑求 $msk$ 这个集合的子集和，当前已经做到了第 $i$ 位，目前的和是多少。

我们把 $msk$ 看作 $(x_0, x_1, \dots x_{n - 1})$。

用直接表示的方法写出 $dp(msk, i)$。

$$dp(msk, i) = \sum\limits_{y_0 \le x_0}\sum\limits_{y_1 \le x_1} \dots \sum\limits_{y_{i - 1} \le x_{i - 1}} a_(y_0, y_1 \dots y_{i - 1}, x_i, x_{i + 1}, \dots x_{n - 1})$$

考虑怎么转移，

就是考虑 $x_i$ 是 $0$ 还是 $1$，如果是 $0$，那么这一维就直接继承上一位的即可

（因为式子是长成 $\sum\limits_{y_i \le x_i}$ 这样的，如果 $x_i$ 是 $0$ 就直接加上前一位的状态）。

如果是 $1$，相当于对着上一位的两种情况都求了和，所以用上一位是 $0/1$ 的两种情况加起来即可：

得到方程：

$$dp(\{x_0,x_1,\dots,x_{n - 1}\},i) = \begin{cases} dp(\{x_0,x_1,\dots x_{i - 1}, 0, x_{i + 1}, \dots x_{n - 1}\}, i - 1) & x_i = 0 \\ \sum\limits_{bit \in \{0, 1\}}dp(\{x_0, x_1, \dots, x_{i - 1}, bit, x_{i + 1}, \dots x_{n - 1}\}, i - 1) & x_i = 1 \end{cases}$$

初始化 $dp(msk, 0) = a_{msk}$。

发现这里 $dp(?,i)$ 的状态只和 $dp(?, i- 1)$ 有关，所以可以考虑滚动数组。

然后发现我们直接从 $0 \sim 2^n - 1$ 枚举 $msk$ 的话，我们甚至可以直接去掉最后一维，因为方程本身的特殊性，这样仍然是无后效性的。

可以自己画图手推，原因类似 01 背包。

可以直接写出代码：

```cpp
for(int msk = 0; msk < (1 << n); ++msk) 
	dp[msk] = a[msk]; 
for(int i = 0; i < n; ++i) {
	for(int msk = 0; msk < (1 << n); ++msk) {
		if(msk & (1 << i))
			dp[msk] += dp[msk ^ (1 << i)];
	}
}
```

这个做法也可以理解为分开对每一维分别做前缀和然后再合起来。

比如二维前缀和就是先对于 $\forall i, s(i,j) \gets s(i, j - 1) + a(j)$，然后 $\forall i, s(i,j) \gets s(i - 1, j) + s(i, j)$