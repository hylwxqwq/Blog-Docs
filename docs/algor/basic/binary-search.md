
## 泛化

作用是在单调的序列或者单调的函数当中进行查找。

也可以将最优化问题转化为可行性问题之后进行判定求解。

## 应用

### 整数域二分

> 问题：在单调递增的序列当中查找大于等于 $x$ 的最小的一个数

开始令两个指针 $l = 1, r = n$，表示我们当前能确定的答案所在的区间。

我们称 $[1, l)$ 为不可行区间，$[r, n]$ 为可行区间（闭开的原因之后会说）。

每次取 $mid = \lfloor (l + r) / 2 \rfloor$。

如果 $a_{mid} \ge x$，那么证明 $[mid, n]$ 就一定是可行区间，因为序列单调递增，证明 $mid$ 之后的 $a$ 都必然 $\ge x$。

所以，我们可以缩小答案区间，令 $r = mid$。

反之，证明 $[1, mid]$ 都是不可行的，所以答案区间的左端点肯定不是 $mid$，所以令 $l = mid + 1$。

当 $l = r$，即答案区间缩小为一个点的时候，此时的 $a_l$ 就是答案。

如果需要判断无解，开始时令 $r = n + 1$ ，如果最后 $l = r = n + 1$ ，那么无解。

这种写法下 $mid$ 永远不会取到 $r$，因为如果 $mid$ 要取到 $r$，就必须让 $l$ 不断收缩过来，而当 $l = r$ 时，循环已经结束了，所以 $mid$ 不可能取到 $r$。

原本的二分区间是 $[1, n]$，现在将其扩大一格变为 $[1, n + 1]$，那么这个越界的下标本身的意义就是“无解”。

```cpp
int l = 1, r = n; // 判无解则令 r = n + 1，这种写法 mid 永远不会取到 r
while(l < r) {
    int mid = (l + r) >> 1;
    if(a[mid] >= x) r = mid; // mid 也可能是答案，也要取。
    else l = mid + 1;
} 
ans = a[l];
```

如果问小于等于，也就是可行区间在 $mid$ 左侧，反过来即可：

只不过为了让越界值为 $0$，需要让 $mid = \lfloor (l + r + 1) / 2 \rfloor$。

理解方式同上。

```cpp
int l = 1, r = n; // 判无解则令 l = 0，这种写法 mid 永远不会取到 l
while(l < r) {
    int mid =(l + r + 1) >> 1;
    if(a[mid] <= x) l = mid; // mid 也可能是答案，也要取。
    else r = mid - 1;
} 
ans = l;
```

一张图理解，下图绿色为可行区间：

[![vC2auT.png](https://s1.ax1x.com/2022/07/28/vC2auT.png)](https://imgtu.com/i/vC2auT)

### 实数域二分

和整数域比较类似，不过设置 $eps$ 即可。

```cpp
double l = 0.0, r = (double)(1e9 + 7), ans;
while(l + eps < r){
    double mid = (l + r) / 2;
    if(valid(mid)) r = mid, ans = mid;
    else l = mid;
} // 也需要根据可行区间的位置判断写法。
```

也可以计算之后设置次数二分。

### 二分答案

如果一个最优解问题的最优解是 $x$ ，并且 $x$ 的一边不合法，一边合法，则这个问题具有单调性。

可以在每次二分的时候将问题转化为是否存在一个方案，使得解为 $mid$ 。

二分答案 $x$ 并进行判定。

然后根据可行区间的方式选择二分方式即可。

此类问题的显著特点就是“最小值最大”，“最大值最小”。

不过也有例外，比如 AGC006D。

### STL 二分

+ `lower_bound` ：在有序序列查找大于等于 $x$ 的第一个。
+ `upper_bound` ：大于 $x$。

如果类似 `set` ，自己带有 `lower_bound`。

就一定选择容器**自身**的：`s.lower_bound(x)` 而不是 `lower_bound(s.begin(),s.end(),x)`。

这样效率更高，因为 $s$ 本身不是类似数组那样的连续访问（他没有支持连续访问的迭代器），他是一个树形结构，所以要用 STL 在树上给你实现的 `lower_bound`。

