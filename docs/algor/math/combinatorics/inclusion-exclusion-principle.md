
## 容斥原理

### 概述

若有 $n$ 个集合 $S_1 \dots S_n$，并且集合之间可能有交集。

那么 $|\bigcup S_i|$ 就等于 $\sum_i |S_i| - \sum_{i, j} |S_i \cap S_j| + \sum_{i, j, k} |S_i \cap S_j \cap S_k| \dots + (-1)^{n + 1} \sum_{a_1, \dots a_n} |\bigcap_j S_{a_j}|$。

$a_1, \dots a_n$ 是用来枚举集合的。

这个柿子也可以简述为，多个集合的并集大小等于奇数个集合的交集的大小之和减去偶数个集合的交集大小之和。

或者描述为:

$\sum$ 在任意一个集合内的元素个数总和 $−\sum$ 在任意两个集合交内的元素个数总和 $+\sum$ 在任意三个集合交内的元素个数总和...

注意这里“在任意两个集合交集内的元素个数总和”是要算重的，也就是说如果 $x$ 在 $A\cap B \cap C$ 当中，那么在算任意两个集合交内的元素个数总和时，$x$ 的贡献就是 $3$。

这么做其实就是为了方便计数，因为有多个条件但是只是“至少”满足一个或者几个的时候，无法比较方便的知道哪些条件满足，哪些条件不满足。

所以我们直接只考虑某些特定的条件一定被满足的时候方案数，其它的直接不管怎么搞，反正不合法或者重复的肯定会被容斥掉。

这就是一种“至少转强制”的思想。

### 一些应用

假设有 $n$ 个条件组成了一个条件集合 $S$，且这些限制建立在一个元素集合 $U$ 上，我们想要知道至少满足一个条件的元素有多少个，此时可以使用容斥原理。

我们将 $U$ 作为全集，设 $s_i$ 表示满足第 $i$ 个条件的所有元素构成的集合。

答案显然是求 $|\bigcup s_i|$ 那么根据容斥原理可以有：

$ans = \sum_i |s_i| - \sum_{i, j} |s_i \cap s_j| + \sum_{i, j, k} |s_i \cap s_j \cap s_k| \dots + (-1)^{n + 1} \sum_{a_1, \dots a_n} |\bigcap_j s_{a_j}|$

这个柿子也可以写成一个更方便的形式，我们令 $p$ 表示 $S$ 的一个子集，即由若干个条件组成的条件集合，设 $f(p)$ 表示满足 $p$ 中所有条件的元素个数，即 $|\bigcap\limits_{s\subseteq p} s|$。

那么 $ans = \sum\limits_{p\subseteq S, p \not= \emptyset} (-1)^{|p|+1} f(p)$。

（这里空集一般来说枚举不枚举都没有啥问题，因为大多数时候 $f(\emptyset) = 0$，如果遇到特殊定义的再看情况就好，为了通用所以排除了空集。）

然后求不满足任意条件的元素就直接 $|U| - ans$ 即可。

## 例题

### 不定方程非负整数解计数

> 给定若干个非负整数 $x_i$，保证 $\sum\limits_{i = 1}^n x_i = m$，求出合法的解的数量，$m \in \mathbb{N}$。

这个东西比较简单，我们放 $m$ 个无差别的小球，然后考虑将其分成 $n$ 组（$1\ 1\ 2$ 和 $1\ 2\ 1$ 不是相同的分法），对合法的分组计数即可。

这个就是插板法，直接用公式就可以了。

> 如果对于每一个 $x_i$ 有一个限制：$x_i \le b_i$，求出合法解的数量，$b_i \in \mathbb{N}$。

这个限制一看长的就像容斥原理里面“满足某一个条件的元素”，这里在对满足所有限制的合法解做计数，所以考虑容斥。

抽象一下 model：

+ 集合 $s$：设 $s_i$ 表示满足第 $i$ 个条件的所有合法解组成的集合。
+ 全集 $U$：所有合法解。
+ 答案 $ans$：$|\bigcup s_i|$。

写出柿子：$ans = |\bigcup s_i| = \sum\limits_{p \subseteq S,p\not= \emptyset} (-1)^{|p| + 1} f(p)$

于是接下来我们要考虑的就只有怎么计算 $f(p)$，考虑任意一个 $S$ 的非空子集 $p$，假设它由 $q$ 个条件 $x(a_i) \le b(a_i)$ 组成（$a_i$ 用于枚举下标）。

嗯，然后发现这个东西很不好算，我们并没有什么头绪，最根本的原因在于这个 $x_i \le b_i$ 的条件是难以计算的。

我们想到，在插板法的几个基本问题里，有一个问题是：“第 $i$ 组的元素至少要有 $v_i$ 个”，转化成不定方程的形式就是 $x_i \ge v_i$，这个东西是容易计数的。

于是我们考虑 __“正难则反”__ 的思想，计算不满足 $x_i \le b_i$ 的合法解个数，也就是考虑计算 $x_i \ge (b_i + 1)$ 的合法解个数，然后用全集 $U$ 的大小减去这个即可（求补集）。

那么对于任意一个 $p$ 的答案就是 $\dbinom{n + \sum\limits_{i = 1}^q (b(a_i) + 1) - 1}{n}$

所以最终的答案是 $\dbinom{n + m - 1}{n} - \sum\limits_{p \subseteq S,p\not= \emptyset} (-1)^{|p| + 1} \dbinom{n + \sum\limits_{i = 1}^q (b(a_i) + 1) - 1}{n}$

### CF997C Sky Full of Stars

> 现在有一个 $n \times n$ 的网格，你有	`RGB` 三种颜色，你需要给每一个格子染色。
>
> 请问至少有一行或者一列颜色相同的方案数有多少？求出这个数对 $998244353$ 取模的值。
>
> $n \le 1e6$。

这个问题是比较经典的“用强制来容掉至少方便计数”的问题。

模型应该比较好看出来，我们把有一行或者一列颜色相同看作 $2n$ 个条件就行。

于是模型抽象出来：

+ 全集 $U$：所有 $3^{n\times n}$ 种染色方案。
+ 集合 $s_i$：满足第 $i$ 行颜色相同的方案构成的集合，当然我们还需要考虑列，这里省略定义了，因为严谨地写起来有点麻烦。
+ 答案 $ans$：$|\bigcup s_i|$。

注意到这里的行和列要分开，不然后面枚举并计算的时候不方便，所以我们设

> 咕咕咕，周末来写。


### ARC101(E/C) Ribbons on Tree
