`May/25/2022`

可能是第一次写模拟赛的复盘。

因为觉得其实很有必要就写了。

### 赛时

拿到题之后简单花了 5 min 调试了下环境。

看第一题，是博弈类的问题但感觉是结论题。

然后看第二题，看起来就很像双指针处理区间。

第三题，没仔细看，感觉不是很好写就 skip 了。

第四题，看了之后第一反应是类似某次 ABC 的 Card 那一题。

----

然后就直接开始写 T1，粗略想了一下之后写了 10 + 30 pts 的部分分。

然后做完之后猜了 100 pts 的结论，写上去发现小样例错在了 `1 1` 这个数据。

然后就加了一个特判。

---

之后看 T2，首先写了一下最简单的暴力，直接枚举所有区间。

注意到 $A_i$ 可能等于 0，所以就打算以 0 为一个边界分段统计答案，把有 0 的位置塞进 `std::set` 就行，然后感觉会有 `size = 0, end()` 之类的边界，初步打算在两边插入 $+-\infty$ 解决。

感觉可能很麻烦，但是我认为不能浪费时间，就把这个问题先记了一下，然后继续往下想。

看了下能不能优化，发现因为 $A_i \ge 0$，所以其实当前的乘积 $mul$ 在 $l$ 固定时时单增的。

所以就考虑双指针，但是忘记了双指针怎么写，所以换了种方式理解。

直接枚举 $l$，这个复杂度 $T_l = O(n)$，然后暴力找到一个 $r$，使得 $\prod\limits_{i = l}^r \ge V$。

并且 $r - l + 1$ 最小。

每次 $l + 1$ 的时候直接利用上次的 $r$ 往后移，更新答案就找到 $l$ 右手边最近的一个 $0$ 的位置 $pos$，如果 $mul \ge V$ 就 $ans + (pos - r)$。

复杂度是 $\max(T_l,T_r\times T_0) = O(n \log n)$，可过。

然后就直接开始写。

先写的是 `std::set` 二分找 $0$ 的过程，然后发现其实不用塞 $\infty$，直接分类讨论就行了。

但是这里比较麻烦的是，万一当前的 $a_l = 0$，二分出来之后可能不好统计，所以当 $a_l = 0$ 的时候直接跳过就行了。

然后想起来移动 $l$ 的时候还要记得除掉 $a_{l - 1}$，还需要判 $0$。

写完之后发现过了小样例，这个时候差不多过了 1h，写了个暴力对拍。

结果发现过不去。

调了很久，中间猜 $l$ 有可能会 $>r$，但是仔细分析之后发现这是不可能的。

后面突然说有大样例了，赶紧测了一发，看暴力是不是写错了。

然后发现暴力确实写错了，之前一遍写出来的 sol 是对的。

但是大样例提醒了我，我的做法要特判 $V = 0$，写了一个 `cout << (n * (n + 1)) / 2`

确认没有问题之后就回去看 T1 了，赛后发现这里忘记我定义的 $n$ 是 `int`，而答案可能是 `long long`，然后就挂了 50pts。

---

手元 T1 很久以后以为，对于整个游戏，只要没有一堆石子的的石子个数是 $1$，那么兔子不可能赢。

因为这是兔子在下一堆变成后手的唯一机会（后来发现不是，因为有可能有很多 $1$）。

这题可以把所有堆分开考虑，先手不管怎么换堆，后手只要紧跟先手在先手上一次放的那一堆放就行，这样相当于，每一堆的过程是独立的。

然后前一堆石子输掉的，下一轮就会是先手。

而我推出来，当前堆的先手必胜，只能是当前堆只有一个石子。

所以只要兔子能抢到先手拿 $1$，之后就一直都是后手，就赢了，

所以我当时认为就只需要判有没有 $1$ 即可。

后来赛后发现，可以有很多个 $1$ 啊，那还需要看 $1$ 的个数的奇偶性啊！！

---

然后看 T4，一直在用 card 的想法去看，但是没有想出来，

发现还剩 1h 不到的时候，赶紧去打了 20pts 的部分分。

写完没过样例，调了一会发现是 $n,k$ 搞混了。

### 赛后

赛时期望 100 + 100 + 0 + 20 = 220 pts。

实际 70 + 50 + 0 + 20 = 140 pts。

T1 比较傻，明明想到最后一步了，但是却没想到一个很小的点，然后就丢了 30pts。

T2 要没有大样例，我可能也检查不出来要判 $V = 0$，所以这 50pts 其实是会丢的。

但是发现了之后却很匆忙的写上，忘记了答案可能是 `long long`。

又因为前面 T1 T2 花太久，所以后面 T3 T4 本来是可做的，都没有去想。

### 总结

1. 检查的时候还要检查特殊情况，特别是 $n = 1, V = 0$ 这种。

2. 对拍之前要确保暴力写对，有大样例就先测一下暴力再对拍。

3. 检查一定不要只检查普通的 subtask，特判的 subtask 也要检查输出之类的。

4. 不知道为什么有的时候就是会想漏一些点，可能是因为某些半对的想法没有深度验证。
   
   这种之后就在考场上用小随机数据不断对拍来验证，或者直接能找到反例就行。

5. 遇到一些麻烦的时候，如果是代码实现或者对接下来的思考不是很必要的问题，可以先记下来，全盘确认无误之后再解决这些小问题。

6. 如果 Editor 有 Auto complete，就尽量使用工程命名方式，这样可以少写一点注释，速度会更快。

但感觉这次状态其实挺好，虽然题可能确实简单，但已经有深入想题的感觉了。

所以虽然挂了分，但感觉都还好。
