# A

【0:02】 构造 $b$ 的一个长度为 $n$ 的子序列 $c$，使得 $\sum a_ic_i$ 最大。

感觉就是个排序不等式。

直接把 $a$ 排序，然后把 $b$ 排序，取最后的 $n$ 位即可。

【0:11】 ：坏了，$a,b$ 有负数。

是不是要沿用排序不等式？还是直接换个思路贪心？

怎么处理负数？

【0:13】： 发现复杂度可以是 $\log$，所以直接扔到 multiset 里面二分一个最优的？

然后 $a$ 可能要按照某种顺序排序？

能不能直接 $a$ 先从小到大，$b$ 也从小到大，对于最小的负数 $a$，我安排一个最小的 $b$。

$b$ 如果是负数那肯定赚了，如果 $b$ 是非负整数，也赚了，因为减小了影响。

大概是正负数分开，然后对于 $a$ 的负数一侧，我从 $b$ 的左端开始贪心，对于 $a$ 的正数一侧，我从 $b$ 的右端开始贪心？

因为 $m \ge n$，所以我两边的指针最多重合一次，不会重复使用。

multiset 也不用了。

感觉是对的，写一下 

【0:18】：写

【0:25】 ：草了，中间改 assert 的时候忘记把 it1, it2 设置到 b 的两端了，所以错了两次。

过大样例了，等下捏几组数据玩，懒得捏了，交了过了。

# B

【0:31】： 感觉一个比较显然的是，对于每个区间我直接 1,2,3,4,5... 拉通。

然后我先直接这么干（假设没有重叠）。

然后再处理重叠，差不多就是先按照类似 Stall Reservation 那题把区间排序一下，然后重了的提出来单独一组。

然后我在每一组里面（都是没有重叠）直接拉通，然后把这个一组一组叠上去。

叠上去的方式大概是把重叠到的地方加一下，具体咋搞要思考一下先？

【0:34】： 小样例太没有一般性了，自己手玩一个：

```
1 2
2 4
3 5
4 6
6 8
6 9
9 10
8 9
```

[![v49RqP.png](https://s1.ax1x.com/2022/08/30/v49RqP.png)](https://imgse.com/i/v49RqP)


差不多这样

[![v492rt.png](https://s1.ax1x.com/2022/08/30/v492rt.png)](https://imgse.com/i/v492rt)

然后我考虑怎么合并。

比如拉一个 $[1, 2] [1,2,3] [1,2,3]$ 出来合并。

显然第二个 `1 2 3` 合并到了 `2 1 2`，不行，，一种办法是 `2 1 3`, 一种办法是 `2 3 4`，然后 `2 1 3 3` 调整成 `2 1 3 4`，合并成 `1 2 1 3 4`。满足。

但是这个咋形式化啊。

【0:46】：好jb烦，懒得想了，洗个脸换 C 看看。

【1:09】：先只考虑 $[1, 2] [1,2,3]$ 合并发现这里实际是“回收“了前面的一个 $1$，然后对于重合的 $1, 2$，我让 $[1,2,3]$ 的 $1$ 变成 $2$，然后就是 $2,2,3$，然后我把回收的 $1$ 用到第二个 $2$ 上，因为这里和 $[1,2]$ 不重合了，可以用了。

```
1 2 3 4 5

    3 4 5 1 2 6
```

所以这个实际上就是，我对于两个重叠的区间，

把不重叠部分的前一半拿出来用，然后从小到大扔到后一半靠前的位置上。

用一个小根堆维护就行了。

【1:20】：开写。

【1:48】：估计是对的，但是可能做法写的有点臭，中间之前自己写的大根堆要实验是不是小根堆结果忘记了，还调了一会，浪费了时间。估计 T了，看 D。

【2:30】：好像，我T喵是傻喵啊。

觉得必然是写臭了。

【2:40】：确实写臭了，改了一下过了。

# C

【0:53】，要对于 $n$ 种情况 $n \log n$ 或者 $\log^2$ 算答案，均摊到一个情况就是 $\log$ 或者 $\log^2$。

感觉就是直接 jb 一个个扫，累加答案，然后维护一个堆一样的东西。

比如我维护一个大根堆，每次加入一个 $i$ 的时候，如果空间还够就直接把 $i$ 扔进去，否则不断弹掉堆顶，但是之后要把弹掉的加进去然后把超了的弹掉。

这个估计是最坏 $n^2\log$ 的，估计只有 50pts，算了看 B 去，等会来打个暴力。

# D

【1:50】 感觉是简单套路题。

就是直接二分，然后 $dp$ check。$dp(i)$ 表示前 $i$ 个最多分多少段使得每段的 $sum \le mid$。

然后可以发现 $dp(i) = \max\limits_{j = 0}^{i - 1}\{dp(j) + 1\}, \land (sum(i) - sum(j) \le mid)$

$O(n^2)$ 的，考虑优化，发现当外层循环 $i$ 固定的时候，我们希望通过

$sum(j)$ 来判断是否存在一个可行的解,所以独立 $sum(j)$，

$sum(j) \ge sum(i) - mid$，这就是条件，维护一下所有满足这个条件的 $dp()$ 最大值即可。

可以权值线段树。

或者树状数组？

就维护一个树状数组，下标是 $sum$ 离散过后的值。

然后 $ask(sum(i))$ 表示询问所有满足 $sum(j) \ge sum(i) - mid$ 的 $dp(j)$ 的最大值。

这个可以直接先二分出一个位置 $pos$ 使得 $sum(pos) \ge sum(i) - mid$。

然后直接树状数组上 $ask(pos)$ 的后缀最大值即可。

就是一个后缀最大值，树状数组即可，复杂度小常数 $\log^2$。

【2:05】 开写。

【2:20】写完，过了。

# 总结

总分: 100 + 100 + 0 + 100，如果在当时赛时就是 rk1了。

代码能力问题，比如 B 那个实现，我一开始直接想的对区间排序之后然后搞，然后发现完全就是麻烦了，直接处理重叠部分就行了。

B 改过之后的做法：赛时想到直接写了，没记录，于是直接赛后找原题找了个做法一样的老哥的思路复制过来，没时间写了。

```
用pre[i]记录一下与当前的这个点i不能出现相同的数据的最左边的那个位置。也就是pre[i]=min(pre[i],l)注意这里时min，因为在左边，我们要取到最长，一定是去最小的那个。这样一些小的区间其实就被覆盖掉了。然后用pl，set，ret分别维护当前已经完成填充的区间的右端点，当前可以用的元素，以及答案。这样，对于每一个i，我们找到pre[i],比较pre[i]和pl的大小，如果pl<pre[i]表示还是由比较多的元素可以继续使用，我们我们把上一次放在ret里面的东西拿出来再次丢进set，然后ret[i]就是set的起始元素，这里其实就保证了字典序最小，因为set是红黑树，所以里面的元素都是有序的排列的。然后把答案记录一下，在set里面移除这个元素。最后输出即可。
https://blog.51cto.com/u_15703975/5433432
```

然后 A 和 B 实现的时候都有因为代码的回撤导致某些地方忘记改了。

比如 A 的两个指针的初始值，B的 pq 没去试一下到底是大根还是小根。

这个咋解决？

然后 D 感觉纯纯套路题，思考了一会才会，之后多复习下以前做的 Trick。

和 whk 的错题复习差不多，不然老是忘记/qd。

因为只打了 3hour，所以没做 C。

还有就是厕所上少了，很多时候没冷静下来，之前不管是whk还是 OI，我有点厌烦某个事情的时候去上个厕所洗个脸，想一下自己为什么应该坚持，或者是否应该更换策略，

还有就是，之后也要和纸质草稿结合一下，整合可以赛后做啊，赛时能让自己懂就行了。

很久没打了，但是状态却比之前好？3h 3题登顶了。

这几道都是贪心，感觉和最近恶补基础有关系，比如那个排序不等式，就是一眼看出来的思路。

然后改一改就过了，D也是。

和 whk 最近在做的事情也一样把，就是在把东西体系化，争取做到看到会的题想一想就有清晰思路，马上就能开写开推导。

