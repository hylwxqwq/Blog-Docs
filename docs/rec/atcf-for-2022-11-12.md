
## 十一 & 十二月 CF AT 丢人做题记录

### ABC277E

> 给你一张简单无向图，每个边 $(u_i, v_i)$ 有一个属性 $a_i$。
>
> 其中如果 $a_i$ 为 $1$ 表示这条边是可以通行的，否则是不可通行的。
>
> 有 $K$ 个特殊点，如果你处于这个特殊点，你可以进行一次转换，使得所有的 $a_i$ 取反。
>
> 问你从 $1 \to n$ 的最短路（无解则答案为 `-1`）。
>
> $2\le n \le 2e5, 1\le m \le 1e5, 0\le K \le n$。

呃呃，感觉是比较板子的分层图最短路。

就是你看到有一些边要在特殊情况下才能通行或者这些边的边权会改变之类的时候，就考虑把边分类。

并且拆点，把图分成多层，如果遇到可以进行不同层转移的节点（比如本题中的特殊点），就在不同层之间连边（这条边的代价取决于在层之间转移的代价）。

之后问题就可以转化成普通的最短路问题了。

对应到这道题上就是考虑把 0/1 状态的边分开连，同层边的边权设置为 $1$，因为我们转换一次不耗费任何代价，所以不同层之间的边的边权是 $0$。

类似这样：

[![znFhE6.png](https://s1.ax1x.com/2022/11/18/znFhE6.png)](https://imgse.com/i/znFhE6)

然后连完边直接求最短路即可。

??? note "Code"
	```cpp
	// author : black_trees

	#include <cmath>
	#include <queue>
	#include <cstdio>
	#include <utility>
	#include <cstring>
	#include <iostream>
	#include <algorithm>

	#define endl '\n'

	using namespace std;
	using i64 = long long;

	const int si = 2e5 + 10;

	int n, m;
	int tot = 0, head[si << 1];
	struct Edge { int ver, Next, w; } e[si << 2];
	inline void add(int u, int v, int w) { e[tot] = (Edge){v, head[u], w}, head[u] = tot++; }

	std::priority_queue<std::pair<int, int> >q;
	bool vis[si << 1]; int dis[si << 1];
	void dijkstra(int s) {
		memset(vis, false, sizeof vis), memset(dis, 0x3f, sizeof dis);
		dis[s] = 0,q.push({dis[s], s});
		while(!q.empty()) {
			int u = q.top().second; q.pop();
			if(vis[u]) continue; vis[u] = true;
			for(int i = head[u]; ~i; i = e[i].Next){
				int v = e[i].ver, w = e[i].w;
				if(dis[v] > dis[u] + w) 
					dis[v] = dis[u] + w, q.push({-dis[v], v});
			}
		}
	}

	int main() {

		cin.tie(0) -> sync_with_stdio(false);
		cin.exceptions(cin.failbit | cin.badbit);

		memset(head, -1, sizeof head);

		int K;
		cin >> n >> m >> K;
		for(int i = 1; i <= m; ++i) {
			int u, v, w;
			cin >> u >> v >> w;
			if(w == 0) add(u + n, v + n, 1), add(v + n, u + n, 1);
			if(w == 1) add(u, v, 1), add(v, u, 1);
		}
		for(int i = 1; i <= K; ++i) {
			int gt; cin >> gt;
			add(gt, gt + n, 0), add(gt + n, gt, 0);
		}
		dijkstra(1);

		int ans = min(dis[n], dis[n + n]);
		if(ans < 0x3f3f3f3f) cout << ans << endl;
		else cout << "-1" << endl;

		return 0;
	}
	```

### ABC279D - Freefall

> 给定两个数 $a$，$b$（$1 \le a, b \le 10^{18}$），求出 $\min\limits_{g = 1}^\infty\{b \times (g - 1) + \frac{a}{\sqrt{g}}\}$。精度误差不超过 $10^{-6}$。
> 
> translated by @[liangbowen](https://www.luogu.com.cn/user/367488)。

设操作次数为 $x$，则总时间为 $T(x) = \dfrac{A}{1+x} + Bx$。

根据初等函数求导法则对 $T(x)$ 求导得：$T^{\prime}(x) = B - \dfrac{A}{2(x+1)^{\frac{3}{2}}}$。

令 $T^\prime(x) = 0 \Rightarrow x = (\dfrac{A}{2B})^{\frac{2}{3}} - 1$。

因为 $x \in \mathbb{N+}$，所以 $x = \text{round}((\dfrac{A}{2B})^{\frac{2}{3}} - 1)$。

注意到 $A, B$ 上界为 $10^{18}$，所以要拆开算。

得到 $x$ 的值之后带入 $T(x)$ 即可得到答案。

不过这种函数求最值的容易出误差，不然就二分，不然就在极值点附近多取几个点求 $\min$，不然难顶。

??? note "Code"
	```cpp
	// author : black_trees

	#include <cmath>
	#include <cstdio>
	#include <cstring>
	#include <iomanip>
	#include <iostream>
	#include <algorithm>

	#define endl '\n'

	using namespace std;
	using i64 = long long;
	using ldb = long double;

	const ldb alpha = (1.0 / 3.0);

	int main() {

		cin.tie(0) -> sync_with_stdio(false);
		cin.exceptions(cin.failbit | cin.badbit);

		ldb a, b; cin >> a >> b, b *= 2.0;
		ldb x = round(((pow(a, alpha) * pow(a, alpha))
					/ (pow(b, alpha) * pow(b, alpha))) - 1.0);
		if(x < 0) x = 0;
		ldb ans = 1e18 + 7;
		for(ldb i = max((ldb)0.0, x - 10.0); i <= min((ldb)1e18 + 7.0, x + 10.0); i += 1.0)
			ans = min(ans, (b / 2.0) * i + (a / sqrt(i + 1.0)));
		cout << fixed << setprecision(10) << ans << endl;

		return 0;
	}

	```

### ABC279E - Cheating Amidakuji

> 给你两个数组 $A$ 和 $B$，初始时，$B_i=i$。
> 
> 定义第 $k$ 次操作为 $\operatorname{swap}(B_{A_k},B_{A_k+1})$
> 
> 定义 $S_i$ 为依次进行 $1$ 到 $m$ 除 $i$ 号操作外的所有操作后，数字 $1$ 在 $B$ 数组中的位置。
> 
> 请依次输出 $S_i$ 。

注意到有些操作是不会影响 $1$ 的位置的，我们只需要关心 $1$ 的位置。

可以先记录直接进行所有操作之后每一个元素的位置 $p$。

注意到 $ans_i$ 是表示不进行操作 $i$ 的情况，所以可以先做 $1 \sim i$，然后看一下当前交换的两个元素 $b(a(i)), b(a(i) + 1)$ 哪个是 $1$，如果 $b(a(i))$ 是 $1$，答案就是 $p(b(a(i) + 1))$，反之亦然，如果都不是 $1$ 证明他们对答案没有影响，答案是 $p(1)$。

复杂度 $O(n)$。

??? note "Code"
	```cpp
	// author : black_trees

	#include <cmath>
	#include <cstdio>
	#include <cstring>
	#include <iostream>
	#include <algorithm>

	#define endl '\n'

	using namespace std;
	using i64 = long long;

	const int si = 2e5 + 10;

	int n, m;
	int a[si], b[si], p[si];

	int main() {

		cin.tie(0) -> sync_with_stdio(false);
		cin.exceptions(cin.failbit | cin.badbit);

		cin >> n >> m;
		for(int i = 1; i <= m; ++i) cin >> a[i];
		for(int i = 1; i <= n; ++i) b[i] = i;
		for(int i = 1; i <= m; ++i) swap(b[a[i]], b[a[i] + 1]);
		for(int i = 1; i <= n; ++i) p[b[i]] = i, b[i] = i;
		for(int i = 1; i <= m; ++i) {
			if(b[a[i]] == 1) cout << p[b[a[i] + 1]] << endl;
			else if(b[a[i] + 1] == 1) cout << p[b[a[i]]] << endl;
			else cout << p[1] << endl;
			swap(b[a[i]], b[a[i] + 1]);
		}

		return 0;
	}

	```

### ABC280D - Factorial and Multiple

> - 给出一个数 $k$，求一个数 $n$，要求 $n!$ 是 $k$ 的倍数，输出 $n$ 的最小值。
> - $k\le10^{12}$
> 
> translated by @[PineappleSummer](https://www.luogu.com.cn/user/880187)。

没啥好说的，分解质因数然后求 $\max\{p_i^{c_i}!\}$ 即可。

??? note "Code"
	```cpp
	// author : black_trees

	#include <cmath>
	#include <cstdio>
	#include <cstring>
	#include <iostream>
	#include <algorithm>

	#define endl '\n'

	using namespace std;
	using i64 = long long;

	const int si = 1e6 + 10;

	i64 c[si]; // exponential
	i64 m = 0, p[si]; // prime factor
	i64 ans = 1;

	void divide(i64 n) {
		m = 0;
		for(i64 i = 2; i * i <= n; ++i) {
			if(n % i == 0) {
				p[++m] = i, c[m] = 0;
				while(n % i == 0) n /= i, c[m]++;
				i64 tmp = 0, t;
				while(c[m] > 0) {
					tmp += i, t = tmp;
					while(t % i == 0) t /= i, c[m] --;
				}
				ans = max(ans, tmp);
			}
		}
		if(n > 1) p[++m] = n, c[m] = 1;
		ans = max(ans, n);
	}

	int main() {

		cin.tie(0) -> sync_with_stdio(false);
		cin.exceptions(cin.failbit | cin.badbit);

		i64 k; cin >> k; 
		divide(k), cout << ans << endl;

		return 0;
	}

	```

### ABC280E - Critical Hit

> 有一个 $n$ 滴血的怪物。每一次攻击你有 $P\%$ 的概率让它失去 $2$ 滴血，有 $(100-P)\%$ 的概率让它失去 $1$ 滴血。如果攻击过后怪物的血量 $\leq 0$，它就死了。你需要一直攻击怪物直到它死亡。输出攻击次数的期望对 $998244353$ 取模的值。
> 
> $1\leq n\leq 2\times10^5,0\leq P\leq 100$

就是简单的期望 dp，但是我一时半会没想清楚。

就是设 $dp(i)$ 表示打死一只体力为 $i$ 的怪物的期望步数。

因为 stamina = 1 的时候怎么打都是 G，所以 $dp(1) = 1$。

方程比较显然，$dp(i) = \dfrac{100 - p}{100}dp(i - 1) + \dfrac{p}{100}dp(i - 2) + 1$ 但是我搞不懂啊，你如果打出了 $i + 1$ 的伤害，那 $i$ 不是照样会 G 吗？

答案怎么就是 $dp(n)$ 了，不懂，不懂。

感觉比较好理解的是倒推？

就设 $dp(i)$ 表示把怪物打到恰好剩 $i$ 的 stamina 的期望步数。

那么 $dp(n) = 0$，答案是 $dp(0) + dp(-1)$，然后求出 $dp(1)$ 之后显然不管怎么打都是可以的。

所以答案实际上是 $dp(1) + 1$。

哦，我懂了，上面的状态是打死，下面的是恰好，有区别的。

??? note "Code"
	```cpp
	// author : black_trees

	#include <cmath>
	#include <cstdio>
	#include <cstring>
	#include <iostream>
	#include <algorithm>

	#define endl '\n'

	using namespace std;
	// using i64 = long long;
	#define int long long

	const int si = 2e5 + 10;
	const int mod = 998244353;

	int n, p;
	int dp[si];
	int qpow(int a, int b) {
		int ret = 1 % mod;
		for(; b; b >>= 1) {
			if(b & 1) ret = ret * a % mod;
			a = a * a % mod;
		}
		return ret % mod;
	}
	int inv(int x) { return qpow(x, mod - 2); }
	const int iv = inv(100);

	signed main() {

		cin.tie(0) -> sync_with_stdio(false);
		cin.exceptions(cin.failbit | cin.badbit);

		cin >> n >> p;
		dp[0] = 0, dp[1] = 1; 
		for(int i = 2; i <= n + 1; ++i)
			dp[i] = ((dp[i - 1] * (100 - p + mod) % mod * iv % mod)
					+ (dp[i - 2] * p % mod * iv % mod) + 1 % mod + mod) % mod;
		cout << dp[n] << endl;
		return 0;
	}

	```
代码是第一个定义。

### ABC281D - Max Multiple

> 给定 $n$ 个数。现在可以从中选 $k$ 个数，需满足他们的和为 $d$ 的倍数。求最大和值。
> 
> translated by @[liangbowen](https://www.luogu.com.cn/user/367488)。

太蠢了，怎么稍微一久甚至连这种神必背包都不会。

怎么回事呢。

就是看到这个从一堆元素里任意选 $K$ 个要满足一定的条件，问某些权值的最值或者是可行的方案数。

然后就是背包嘛，然后数据范围都是 $100$，很容易想到设 $dp(i,j,k)$ 表示考虑前 $i$ 个元素选了 $j$ 个，且已经选择的元素的模 $D$ 意义下和为 $k$ 的时候的 $\max\sum$。

终态 $dp(N, K, 0)$。

转移比较简单就选或者不选，$O(NKD)$。

只能说越来越傻逼了，状态不初始化 inf 初始化 -1 根本不够，然后转移的时候乱转移状态，同一层转移两个不同状态，纯纯nt.

??? note "Code"
	```cpp
	// author : black_trees

	#include <cmath>
	#include <cstdio>
	#include <cstring>
	#include <iostream>
	#include <algorithm>

	#define endl '\n'

	using namespace std;
	using i64 = long long;

	const int si = 1e2 + 10;

	int N, K, D, a[si];
	i64 dp[si][si][si];

	int main() {

		cin.tie(0) -> sync_with_stdio(false);
		cin.exceptions(cin.failbit | cin.badbit);

		cin >> N >> K >> D;
		for(int i = 1; i <= N; ++i)
			cin >> a[i];
		memset(dp, -0x3f, sizeof dp);
		dp[1][0][0] = 0, dp[1][1][(a[1] % D)] = a[1];
		for(int i = 2; i <= N; ++i) {
			for(int j = 0; j <= min(i, K); ++j) {
				for(int k = 0; k < D; ++k) {
					dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k]);
					if(j > 0)
						dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][((k - a[i]) % D + D) % D] + a[i]);
				}
			}
		}
		cout << ((dp[N][K][0] < 0) ? -1 : dp[N][K][0]) << endl;
		return 0;
	}

	```

### ABC281E - Least Elements

> 给定一个序列 $A$，对于每个 $1 \le i \le N - M + 1$，将 $A_i A_{i + 1} \cdots A_{i + M - 1}$ **从小到大**排序后（不影响原序列），求出 $\mathrm{ans}_i = \sum\limits_{i=1}^{K}A_i$。

感觉这种对于一个序列做很多个 independent problem 的时候一般都会要考虑从上一个状态继承，或者是考虑先整体做一遍再计算 ignore 一些操作之后的影响之类的。

这一题是，279E 也是，其实很经典感觉，之前好像有一个 CF 的题也是类似，有点久远记不清楚了。

就是先考虑对于 $i = 1$ 直接暴力做一次，然后我们发现每次挪一步就少一个多一个元素而已，所以我们只需要动态维护前 $k$ 大的 $\sum$ 就可以，每次弹出一个元素，然后加入一个新元素看有没有变化。

这个过程可以直接 multiset 维护，思想和莫队很像，但是边界好TM烦啊，不是很懂啊，好像要两个 multiset 维护，我一个 multiset 假了，不是很懂。

----

说句鲜花，发现早上的时候确实清醒很多，感觉以后不能浪费早上的时间了。

CF35E 全是早上挑出重大 bug，今天上午做题效率很高。

哦还有感觉以后做题之前可以先翻一下以前的博客找找？状态？

----

### CF1770 - Goodbye2022

感觉是今年打的最好的一场。

从各种意义上来说都是，感觉自己能尝试一下 D 这种披着博弈论皮的题已经算进步了，以前看到 both play optimally 就不敢做（

回来的地铁上和一个特别厉害的前 MOer 聊天，他说他做题一般是要先想方法，没有确切思路绝对不开始写，不然就先尝试简化题目然后继续思考。

而且一般来说要尝试分析考点然后找到方向，使劲往那个方向靠。

而且一般来说不能有 phobia，得先思考一下，别被吓到了。

感觉很有道理！说的太对了！

虽然别人的方法不一定适合，但是感觉这个确实会比较有用！

[![pS9mO7q.png](https://s1.ax1x.com/2022/12/31/pS9mO7q.png)](https://imgse.com/i/pS9mO7q)

#### A - Koxia and Whiteboards

没什么好说的。

#### B - Koxia and Permutation

> 你需要构造一个排列 $p$，使得 $\max\limits_{i = 1}^{n - k + 1}\{\max(a_i \dots a_{i + k - 1}) + \min(a_i \dots a_{i + k - 1})\}$ 最小。
>
> $n, k$ 给定，$2e5$。

注意到我们一定希望整体的 $\max,\min$ 凑到一起，我们把他们放到一个区间之后去掉他们，然后可以递归的发现就是不断让 $\max \min$ 放到一起。

然后瞎构造一下就可以了，我开始的思路是直接放区间左右端点，但是感觉比较麻烦，然后发现其实答案和 $k$ 无关，直接 $\max \min$ 这样挨着放就行了。

??? note "赛时Code"
	```cpp
	// author : black_trees

	#include <cmath>
	#include <cstdio>
	#include <cstring>
	#include <iostream>
	#include <algorithm>

	#define endl '\n'

	using namespace std;
	using i64 = long long;

	const int si = 2e5 + 10;

	int a[si];

	int main() {

		cin.tie(0) -> sync_with_stdio(false);
		cin.exceptions(cin.failbit | cin.badbit);

		int T; cin >> T;
		while(T--) {
			int n, k;
			cin >> n >> k;
			for(int i = 1; i <= n; ++i) {
				if(i & 1) cout << (n - i / 2) << " ";
				else cout << (i >> 1) << " ";
			}
			// int l = 1, r = n;
			// int pos = 1;
			// while(l <= r) {
	//
			// }
			// for(int i = 1; i <= n; ++i) cout << a[i] << " ", a[i] = 0;
			cout << endl;
		}

		return 0;
	}

	```

#### C - Koxia and Number Theory

> 给定一个序列 $a$, 判断是否存在一个正整数 $x$ 使得 $\forall 1 \le i < j \le n, \gcd(a_i + x, a_j + x) = 1$。
>
> $1\le n \le 2e5, 1\le a_i 1e18$

问题等价于判断是否存在一个 $x$ 使得每一个值域内的质数都至多整除一个 $a_i + x$。

但是值域是 $10^{18}$，思考一下能否缩小范围。

发现对于一个质数 $p$，显然我们要做的是对 $a_i \mod p$ 意义下的余数计数，所以其实对于当前枚举到的 $p$，如果它大于 $n$，显然一定存在至少一个余数的出现次数数是一定会大于 $2$ 的，所以寄。

那么就枚举 $[2,n]$ 范围内的质数就行了，发现其实合数对答案没影响，所以质数都不需要判了。

记得判相等的 $a_i, a_j$。

??? note "Code"
	```cpp
	// author : black_trees

	#include <cmath>
	#include <cstdio>
	#include <cstring>
	#include <iostream>
	#include <algorithm>

	#define endl '\n'

	using namespace std;
	using i64 = long long;

	const int si = 2e5 + 10;

	i64 a[si], b[si];

	int main() {

		cin.tie(0) -> sync_with_stdio(false);
		cin.exceptions(cin.failbit | cin.badbit);

		int T; cin >> T;
		while(T--) {
			bool f = false;
			int n; cin >> n;
			for(int i = 1; i <= n; ++i) cin >> a[i];
			for(int i = 1; i <= n; ++i) {
				for(int j = i + 1; j <= n; ++j) {
					if(a[i] == a[j]) {
						f = true; break;
					}
				}
				if(f) break;
			}
			if(f) { cout << "No" << endl; continue; }
			for(int p = 2; p <= n; ++p) {
				for(int i = 0; i <= p; ++i) b[i] = 0;
				for(int i = 1; i <= n; ++i) b[a[i] % p] += 1;
				bool ff = false;
				for(int i = 0; i < p; ++i) if(b[i] <= 1) { ff = true; break; } 
				if(ff != true) { f = true; break; }
			}
			if(f) cout << "No" << endl;
			else cout << "Yes" << endl;
		}

		return 0;
	}

	```

#### D - Koxia and Game

> 给定两个序列 $a, b$，要求构造一个序列 $c$ 使得以下游戏先手必胜。
>
> 在游戏的第 $i$ 轮，先手从 $a_i, b_i, c_i$ 当中选取一个数删掉，然后后手在剩下的两个数里面选择一个，这次决策选择的数记为 $d_i$。
>
> 如果 $d$ 是一个 $1\sim n$ 的排列，那么先手获胜，双方均采取最优策略。
>
> 请问有多少种合法的构造方案？对 $998244353$ 取模。
>
> $1\le n \le 1e5$。

注意到这里是合法方案计数，所以显然我们需要知道什么样的方案是合法的。

观察样例发现会有无解的情况，发现不是很好判定，先考虑有解怎么算。

赛时这个时候突然冒出来一个思路，比较神奇，也不知道怎么想到的，可能是想尝试分析这个最优策略是什么的时候想到的。

就是发现其实这个游戏是由先手操纵的，和后手并没有任何关系。

因为只给出了 $a_i, b_i$，所以其实先手可以强制后手选择 $a_i\ \text{or}\ b_i$，具体方式是令 $c_i$ 和需要强制后手选的那个数一样，然后删掉另外一个不同的即可。

考虑一下这个是不是最优策略，发现一定是，比如 `1 1 2`，你肯定不希望后手能有更多选择，不然你没法考虑后面的情况，比较容易寄掉，于是合理推测只能这么干！

然后考虑怎么算贡献，发现这个东西好像可以抽象成图论，就直接对于 $i$，连 $(a_i, b_i)$ 这条无向边就行。

如果找到了一个自环，这里的贡献显然是 $n$，因为 $c_i$ 取任意一个数，先手都可以删掉，就比如 `1 1` 这样。

然后注意到其实合法方案应该是一个基环树森林，如果环不是自环，那么贡献一定是 $2$，因为你每次之有两种选择，然后连通块里面的方案是会相互影响的，你好比选了两条路走出去这样。

那么其实自环的贡献应该在它所属的联通块里面直接算，所以我们直接 dfs 一下，判一下自环和无解就行了。

无解显然就是连通块不是基环树，也就是树的情况，那么就很好做了。

当然也有可能是凑不出排列，这个特判 vis 就行。

这里放的是赛时代码，错误思路的东西没来得及删，凑合着看。

这题也比较有纪念意义感觉，毕竟是 15 岁的我做的最后一题，16 岁的我做的第一题。

点名批评 15 岁的我，怎么判重复二元组这种假做法都能想到 :angry:

??? note "Code"
	```cpp
	// author : black_trees

	#include <map>
	#include <cmath>
	#include <cstdio>
	#include <cstring>
	#include <utility>
	#include <iostream>
	#include <algorithm>

	#define endl '\n'
	#define int long long

	using namespace std;
	using i64 = long long;

	const int si = 2e5 + 10;
	const int mod = 998244353;

	int a[si], b[si];
	std::map<std::pair<int, int>, bool> mp;
	bool vis[si];
	int head[si], tot = 0;
	struct Edge { int ver, Next; } e[si << 1];
	inline void add(int u, int v) { e[tot] = (Edge){v, head[u]}, head[u] = tot++; } 

	int dg, sf, deg[si];
	void dfs(int u, int fa) {
		vis[u] = true; dg -= 2;
		for(int i = head[u]; ~i; i = e[i].Next) {
			int v = e[i].ver; dg++;
			if(u == v) sf++; // self ring.
			if(v == fa || vis[v] == true) continue;
			dfs(v, u);
		}	
	}

	signed main() {

		cin.tie(0) -> sync_with_stdio(false);
		cin.exceptions(cin.failbit | cin.badbit);

		int T; cin >> T;
		while(T--) {
			bool f = false; mp.clear(), tot = 0;
			int n, ans = 1ll; cin >> n;
			for(int i = 0; i <= n + 10; ++i) vis[i] = false, head[i] = -1, deg[i] = 0;
			for(int i = 1; i <= n; ++i) cin >> a[i];
			for(int i = 1; i <= n; ++i) cin >> b[i];
			// for(int i = 1; i <= n; ++i) {
				// std::pair<int, int> t = make_pair(min(a[i], b[i]), max(a[i], b[i]));
				// if(mp[t] == true) {	f = true; break; }
				// mp[t] = true;
				// if(a[i] == b[i]) ans = (ans * n) % mod, vis[i] = true;
				// else add(a[i], b[i]), add(b[i], a[i]);
			// }
			for(int i = 1; i <= n; ++i) deg[a[i]] ++, deg[b[i]] ++, add(a[i], b[i]), add(b[i], a[i]);
			// if(f) { cout << "0" << endl; continue; }
			for(int i = 1; i <= n; ++i) {
				if(!vis[i]) {
					dg = 0, sf = 0, dfs(i, 0);
					if(dg != 0) { ans = 0; break; }
					if(sf) ans = (ans * n) % mod;
					else ans = (ans + ans) % mod; 
				}
			}
			for(int i = 1; i <= n; ++i) {
				if(!deg[i]) { ans = 0; break; }
			}
			cout << ans << endl;
		}

		return 0;
	}

	// dottle : 364577
	```

